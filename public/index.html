<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Welcome!</title>
    <script src="https://unpkg.com/vue@next"></script>
    <script src="https://unpkg.com/naive-ui@2.32.1"></script>
    <script src="/site/protobuf-light.js"></script>
    <style>
      body {
        padding: 16px;
        box-sizing: border-box;
        margin: 0;
        width: 100vw;
        height: 100vh;
      }
      .flex {
        display: flex;
      }
      .flex-col {
        flex-direction: column;
      }
      .around {
        justify-content: space-around;
      }
      .btn-group {
        margin-top: 20px;
      }
      .btn-group button {
        margin: 5px;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <h2>Welcome index</h2>
      <div class="protobuf"></div>
      <div class="flex around">
        <n-statistic label="online" tabular-nums style="width: 100px">
          <n-number-animation :from="0" :to="online" />
        </n-statistic>
        <n-collapse>
          <n-collapse-item title="websocket-status" name="1">
            <div class="ws-status-wrapper">
              <div class="item" v-for="item in status">{{ item }}</div>
            </div>
          </n-collapse-item>
          <n-collapse-item title="websocket-chat" name="2">
            <div class="ws-chat-wrapper">
              <div class="item" v-for="item in messages">{{ item }}</div>
            </div>
          </n-collapse-item>
        </n-collapse>
      </div>

      <div style="padding: 10px">
        <n-input v-model:value="sendValue" type="textarea" placeholder="please input" />
      </div>

      <div class="btn-group">
        <n-button @click="deal">test protos</n-button>
        <n-button @click="send">send message</n-button>
      </div>
    </div>

    <script>
      let $root = undefined
      const scheme = window.location.protocol
      async function main() {
        const json = await fetch(`${scheme}//localhost:3888/site/proto.json`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        }).then(res => res.json())

        if (protobuf && protobuf.roots) {
          $root = protobuf.roots["default"] = new protobuf.Root()
          $root.addJSON(json.nested)

          const PBMessageResponse = $root.lookup("ns.AwesomeMessage")
          console.log(PBMessageResponse)
          const buffer = await fetch(`${scheme}//localhost:3888/proto/encode`, {
            method: "GET",
            headers: {
              "Content-Type": "application/x-protobuf",
              Accept: "application/x-protobuf"
            }
          }).then(res => res.arrayBuffer())

          const buf = protobuf.util.newBuffer(buffer)
          if (!PBMessageResponse) {
            throw new Error(`Not parse with $root.lookup`)
            return
          }
          // decode响应体
          const decodedResponse = PBMessageResponse.decode(buf)
          console.log(`decode success: 👇🏻👇🏻👇🏻 \n`, decodedResponse)
          document.querySelector("div.protobuf").innerHTML = JSON.stringify(decodedResponse.toJSON(), null, 2)
        }
      }

      const { createApp, h, ref, unref, onMounted } = Vue

      const App = {
        setup() {
          const connecting = ref(false)
          // { type, data }
          const messages = ref([])
          // connect status records
          const status = ref([])
          const online = ref(0)
          const sendValue = ref("")
          const showMessage = ({ type, data }) => {
            console.log(`showMessage`, type, data)
            if (type === "count") {
              online.value = data
              return
            }
            messages.value = [...messages.value, data]
          }
          const openChannel = callback => {
            if (typeof callback === "function") {
              callback(`hello everyone~`)
            }
          }
          const recordStatus = data => {
            status.value = [...status.value, data]
          }
          let ws
          // key: url,onOpen,onChannelOpened,onMessage,onClose,onError
          function useWsConnection(props) {
            onMounted(() => {
              recordStatus("WebSocket will start connection...")
              ws = new WebSocket(props.url)

              ws.onopen = () => {
                recordStatus("WebSocket connection opened")
                props.onOpen()
                props.onChannelOpened(function (message) {
                  if (ws.readyState === 1) {
                    ws.send(message)
                  }
                })
              }

              ws.onmessage = event => {
                console.log(`[onmessge]`, event.data)
                try {
                  const json = JSON.parse(event.data)
                  switch (json.type) {
                    case "accepted":
                    case "count":
                    case "message":
                      props.onMessage(json)
                      break
                  }
                } catch (e) {
                  recordStatus("Invalid JSON: ", event.data)
                }
              }

              ws.onclose = function (event) {
                recordStatus(`WebSocket connection closed, readyState: ${ws.readyState}`)
                console.log(`[onclose]: `, event)
                props.onClose()
              }

              ws.onerror = function (error) {
                recordStatus(`WebSocket error, readyState ${ws.readyState}`)
                console.log("[onerror]: ", error)
                if (ws.readyState === 1) {
                  props.onError(error)
                  ws.close(error)
                }
              }
            })
          }
          useWsConnection({
            url: `wss://localhost:3888/ws/chat`,
            onOpen: () => (connecting.value = false),
            onChannelOpened: openChannel,
            onMessage: showMessage,
            onClose: () => {
              connecting.value = true
              console.log(`Disconnected`)
            },
            onError: err => {
              connecting.value = true
              console.error(err)
            }
          })
          return {
            messages,
            deal: main,
            status,
            online,
            sendValue,
            send: () => {
              console.log(`--->`, sendValue.value, ws.readyState)
              if (ws && ws.readyState === 1 && sendValue.value) {
                ws.send(JSON.stringify({ type: `message`, data: sendValue.value }))
                sendValue.value = ``
              }
            }
          }
        }
      }
      const app = Vue.createApp(App)
      app.use(naive)
      app.mount("#app")
    </script>
  </body>
</html>
